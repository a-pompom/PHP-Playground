# 概要

複数の要素を走査するためのIteratorパターンを学ぶ。

## 用語

* Iterator: 反復処理のためのインタフェースを提供するオブジェクト
* Iterable: Iteratorを介して反復可能なオブジェクト

## 解決したい課題

複数の要素を反復しながら走査したいとき、要素の実体に依存せずに反復処理を実装したい。
例えば、反復対象が配列・自作クラス・隣接リストなどいかなるものでも同じ形式で反復できるようにしたい。

同じように反復できれば、反復処理を書きやすく・変更しやすくできる。

## どう解決するか

複数の要素をIterableなオブジェクトから得たIteratorを介して反復することで、反復処理を同じインタフェースで定義できるようにする。
言い換えれば、反復処理を共通のインタフェースで抽象化することを目指す。

### なぜAggregate/Iterable Interfaceが必要なのか

反復処理を共通のインタフェースで定義するのであれば、反復対象でAggregate/Iterableインタフェースのメソッドを実装すれば良いように思える。
今回の例では、BookShelfクラス自身が`next()`, `hasNext()`を持つ方がシンプルだ。
なぜわざわざIteratorオブジェクトを別につくっているのだろうか。

これは、何度も繰り返し反復処理を実行するときに、状態をシンプルに保つためである。
反復対象自身が反復条件を管理していると、繰り返しの度に内部の状態を初期化しなければならない。状態を変更するような処理は問題を生みやすく、極力書かないようにしたい。
※ 状態を逐一書き換えていると、処理の時点で状態がどのようであるか予測しづらく、想定しない状態となる可能性がある。

ここで、反復の度にIteratorオブジェクトを生成すれば、簡単に状態をリセットできる。
つまり、反復の状態をIteratorオブジェクトで表現することで、状態の変わりやすい反復処理をシンプルに扱えるようにすることを目指した。
